Vamos a añadir un Menu de Opciones para gestionar volumen de musica.

Creamos un menu con la misma disposicion del GamePaused.
Dejamos solo el boton de autocerrarse. 
Añadimos un texto, un scrollbar y el texto como valor (un trio para la musica y otro para los efectos de sonido o sfx).
En el GamePausedUI, metemos dos variables de editor mas, una ara el container nuevo y un boton de entrar a las opciones.
En el evento del boton, hacemos SetActive(true) del contenedor y metemos un false si se quita la pausa en el OnPauseAction.
En el SoundManager, añadimos el AudioSource de la musica y lo vinculamos.
Creamos dos public static string para las KEYS donde guardaremos los volumenes.
Metemos una variable privada, en el Start con el valor actual de los sfx:
        sfxVolume = PlayerPrefs.GetFloat(SFX_VOLUME, 0.75f);
        music.volume = PlayerPrefs.GetFloat(MUSIC_VOLUME, 1.0f);
Creamos dos metodos de cambio de volumen:
    public void ChangeMusicVolume(float newMusicVolume) {
        PlayerPrefs.SetFloat(MUSIC_VOLUME, newMusicVolume);
        music.volume = newMusicVolume;
    }
    public void ChangeSFXVolume(float newSfxVolume) {
        sfxVolume = newSfxVolume;
        PlayerPrefs.SetFloat(SFX_VOLUME, sfxVolume);
    }
Cambiamos el PlaySound para que use el volumen de la variable.

Hacemos un script OptionsUI, con sus variables de editor de los textos del valor del audio/sfx, las scrollbars, su container y su boton de cerrar.
Con el boton de cerrar, desactibamos el container.
Con los scrollbars, onValueChanged, llamamos al SoundsManager en el ChangeVolume que toque y actualizamos el valor del texto redondeando * 10:
        musicScrollbar.onValueChanged.AddListener(newValue => {
            SoundsManager.Instance.ChangeMusicVolume(newValue);
            musicText.text = Mathf.CeilToInt(newValue * 10).ToString();
        });
        sfxScrollbar.onValueChanged.AddListener(newValue => {
            SoundsManager.Instance.ChangeSFXVolume(newValue);
            sfxText.text = Mathf.CeilToInt(newValue * 10).ToString();
        });

En el start, desactivamos, pillamos el valor del PlayerPrefs, actualizamos texto y barra y volvemos a activar. Asi no se lanzará ningun evento.

Video a 9:22:20
NOS SALTAMOS LA PARTE DE REBINDING (Reasignar valores a los inputs)
Video a 9:45:40

Ahora queremos poder navegar por los menus con el gamepad.
Primero añadamos un DeadZone a las PlayerInputActions del Joystick.
En el GameScene, EventSystem, nos dara un warning en el StandaloneInputSystem, clicamos en el boton que nos da y se cambiara a InputSystemUIInputModule
Buscamos todos los botones que hemos hecho, le metemos un selected Color en verdecino (47DB22).
En el Paused, pillamos un boton y lo seleccionamos en el OnPauseAction, si entramos en pausa.
Lo mismo cuando abrimos el Options Menu, creamos una funcion de OpenOptions donde seleccionamos uno de ellos.
Tambien una CloseOptions y las llamamos desde el pause menu, cambiando gameObject por el tipo del menu.

El movimiento por el menu que tiene Unity por defecto, va por todos los botones que se muestran en pantalla. Miramos de que cuando se abran las opciones, se cierre la pausa y viceversa.
Creamos un evento para cuando cerramos desde el menu de opciones, que el pause se pueda reactivar, pero el evento lo llamamos solo en la accion del boton de cerrar.

Para el menu principal tan solo necesitamos marcar por defecto el boton de play en el EventSystem -> First Selected. Y añadimos el color de selected.

NOTA: Para el pause el Enter no sirve, ya que interfiere con el movimiento por los menus por defecto. Mejor usar ESCAPE o otra.

Fin de session. Video a 9:22:20